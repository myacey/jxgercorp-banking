// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transfer.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTransfer = `-- name: CreateTransfer :one
INSERT INTO
    transfers (
        id,
        from_account_id,
        to_account_id,
        currency_code,
        amount,
        from_account_username,
        to_account_username
    )
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, from_account_id, to_account_id, amount, created_at, currency_code, from_account_username, to_account_username
`

type CreateTransferParams struct {
	ID                  uuid.UUID
	FromAccountID       uuid.UUID
	ToAccountID         uuid.UUID
	CurrencyCode        string
	Amount              int64
	FromAccountUsername string
	ToAccountUsername   string
}

func (q *Queries) CreateTransfer(ctx context.Context, arg CreateTransferParams) (Transfer, error) {
	row := q.db.QueryRow(ctx, createTransfer,
		arg.ID,
		arg.FromAccountID,
		arg.ToAccountID,
		arg.CurrencyCode,
		arg.Amount,
		arg.FromAccountUsername,
		arg.ToAccountUsername,
	)
	var i Transfer
	err := row.Scan(
		&i.ID,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.Amount,
		&i.CreatedAt,
		&i.CurrencyCode,
		&i.FromAccountUsername,
		&i.ToAccountUsername,
	)
	return i, err
}

const searchTransfers = `-- name: SearchTransfers :many
SELECT id, from_account_id, to_account_id, amount, created_at, currency_code, from_account_username, to_account_username
FROM transfers
WHERE
    -- проверка текущего пользователя
    (
        from_account_id = $1
        OR to_account_id = $1
    )

    -- фильтрация по второму участнику (username)
    AND (
        $2::TEXT IS NULL
        OR from_account_username =$2
        OR to_account_username = $2
    )

    -- фильтрация по второму участнику (account_id)
    AND (
        $3::UUID IS NULL
        OR from_account_id = $3
        OR to_account_id = $3
    )

    -- по валютам
    AND (
        $4::TEXT IS NULL
        OR currency_code = $4
    )
ORDER BY created_at DESC
LIMIT $6 OFFSET $5
`

type SearchTransfersParams struct {
	CurrentAccountID uuid.UUID
	WithUsername     pgtype.Text
	WithAccountID    pgtype.UUID
	Currency         pgtype.Text
	Offset           int32
	Limit            int32
}

func (q *Queries) SearchTransfers(ctx context.Context, arg SearchTransfersParams) ([]Transfer, error) {
	rows, err := q.db.Query(ctx, searchTransfers,
		arg.CurrentAccountID,
		arg.WithUsername,
		arg.WithAccountID,
		arg.Currency,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transfer{}
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.ID,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.Amount,
			&i.CreatedAt,
			&i.CurrencyCode,
			&i.FromAccountUsername,
			&i.ToAccountUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
